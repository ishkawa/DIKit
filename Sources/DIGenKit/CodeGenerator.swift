//
//  CodeGenerator.swift
//  dikitgenTests
//
//  Created by Yosuke Ishikawa on 2017/09/16.
//

import Foundation
import SourceKittenFramework
import Stencil

public final class CodeGenerator {
    let context: [String: Any]

    public convenience init(path: String, excluding exclusions: [String] = []) throws {
        try self.init(files: files(atPath: path, excluding: exclusions))
    }

    public init(files: [File]) throws {
        let types = try Array(files
            .map { file in
                return try Structure(file: file)
                    .substructures
                    .flatMap { Type(structure: $0, file: file) }
            }
            .joined())

        let imports = try Array(files
            .map { file -> [Import] in
                return try Import.imports(from: file)
            }
            .joined())
            .reduce([] as [Import]) { imports, newImport in
                return imports.contains(where: { $0.moduleName == newImport.moduleName })
                    ? imports
                    : imports + [newImport]
            }

        let resolvers = try types
            .flatMap { type -> Resolver? in
                do {
                    return try Resolver(type: type, allTypes: types)
                } catch let error as Resolver.Error where error.reason == .protocolConformanceNotFound {
                    return nil
                } catch {
                    throw error
                }
            }

        context = [
            "moduleNames": imports.map({ $0.moduleName }).sorted(by: <),
            "resolvers": resolvers.sorted { (lhs, rhs) in return lhs.name < rhs.name },
        ]
    }

    public func generate() throws -> String {
        let template = Template(templateString: """
            //
            //  Resolver.swift
            //  Generated by dikitgen.
            //

            {% for moduleName in moduleNames %}import {{ moduleName }}{% if not forloop.last %}
            {% endif %}{% endfor %}
            {% for resolver in resolvers %}
            extension {{ resolver.name }} {
            {% for method in resolver.sortedGeneratedMethods %}
                func {{ method.name }}({{ method.parametersDeclaration }}) -> {{ method.returnTypeName }} {
                    {% for line in method.bodyLines %}{{ line }}{% if not forloop.last %}
                    {% endif %}{% endfor %}
                }
            {% endfor %}
            }
            {% endfor %}
            """)

        return try template.render(context)
    }
}

private func files(atPath path: String, excluding exclusions: [String]) -> [File] {
    let exclusions = exclusions.map { $0.last == "/" ? $0 : $0 + "/" }
    let url = URL(fileURLWithPath: path)
    let fileManager = FileManager.default

    var files = [] as [File]
    var isDirectory = false as ObjCBool
    if fileManager.fileExists(atPath: url.path, isDirectory: &isDirectory) {
        if isDirectory.boolValue {
            let enumerator = fileManager.enumerator(atPath: path)
            while let subpath = enumerator?.nextObject() as? String {
                if exclusions.contains(where: { subpath.hasPrefix($0) }) { continue }

                let url = url.appendingPathComponent(subpath)
                if url.pathExtension == "swift", let file = File(path: url.path), file.contents.contains("DIKit") {
                    files.append(file)
                }
            }
        } else if let file = File(path: url.path) {
            files.append(file)
        }
    }

    return files
}
